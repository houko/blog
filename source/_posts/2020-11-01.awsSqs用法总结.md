---
author: 小莫
date: 2020-11-01
title: AWS SNS用法总结
tags:
- sqs
category: aws
permalink: AwsSqsUse


---

最近做一个功能的时候需要用到消息队列，提起消息队列首先想到的就是mq系列的rabbitMQ或者rockMQ,Kafuka之类的服务。但另外aws也有自己的消息队列服务SNS和SQS，今天简单记录一下SQS和SNS的用法。
<!-- more -->

# mq和kafuka对比

## 业务场景分析 

kafka 适合简单业务，性能极强，用于大数据领域的实时计算以及日志采集。

rocketmq 功能多，坑多，性能好， 用于大公司的业务

rabbitmq 功能多，简单易用，性能较差。用于中小公司的业务

activeMQ, 它是消息队列，叫做messagequeen，我们是使用在电商平台上。比如当用户商品上架的时候，它将用户的商品信息，它就是一个消息服务中间件，里面保存了参数值，就是商品上架的同时，将商品的ID信息保存到消息服务的中间件中，这是这一端，然后我到另一端，solr服务端和我的freemarker服务端都会反复不断的监听，监听activeMQ中的一些相应的参数信息，就是ID，如果找到了ID信息,那么我就会相应处理，而且activeMQ可以采用一对一模式和主题订阅模式。当引用了activeMQ的时候，它将用户的商品信息保存到消息服务中间件，然后我的另外2个，一个solr，一个freemarker这2个服务器都可以同时或者很短的时间内异步监听到ID信息，同时取出这个信息，异步的进行先相关处理，这样可以节约大量的时间，这就是为什么用,activeMQ是节省时间的。



### 社区

rocketmq 社区不太活跃，文档少，相对不太成熟，需要**踩坑**，不过是用 java 编写。

其他两个比较活跃，rabbitmq 是 erlang 编写，源码学习成本较高。

### 功能

rocketmq 和 rabbitmq 支持的功能较多，更适合业务。

### 接口

rocketmq 自己一套接口，有学习成本。

### 延迟和性能

rabbitmq 延迟低，性能差 rocketmq 一倍。kafka 最强。

rabbitmq 的集群模式感觉不太合理， producer 不知道 queue 数据在哪台机器上，只能挑一台发送，broker如果发现queue数据不在当前节点上就帮你转发，这样产生一次转发的开销。

[Kafka、RabbitMQ、RocketMQ等消息中间件的介绍和对比_Brave Soul Blog-CSDN博客blog.csdn.net![图标](https://pic2.zhimg.com/v2-a97ab4d23db1a20da423b5bca98da5c9_180x120.jpg)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/yunfeng482/article/details/72856762)

### 队列数对性能的影响

-   kafka 单台机器 队列数量大于 64的时候，负载大幅增加。
-   rabbitmq 的集群模式下，会在所有集群节点中同步队列的元信息。有一定的开销，也意味着队列数不宜过多。
-   rocketmq 单台机器撑住五万的队列，由于有专门的namesrv节点存储元信息。所以集群能够存储很多很多队列。

kafka 表现最差，但是得益于性能高，还是适用于队列数少，数据量大的场景。

### 有序性

rocketmq 可以很容易实现消息有序性。

rabbitmq 很麻烦

kafka 不清楚。

### 支持事务

mq 支持这个功能不是刚需，有别的办法可以实现类似事务的效果。



# SQS是什么

SQS(Simple Queue Service)提供高吞吐量的系统到系统消息收发队列。您可以使用队列来解耦高开销流程，并实现作业的缓冲和批处理。Amazon SQS 会在微服务和无服务器应用程序完成处理前一直存储消息。

# SQS作用

### 高度可扩展的标准队列和 FIFO 队列

队列可根据应用程序的需要弹性扩展。标准队列提供几乎无限的吞吐量，每个队列的消息数量也无限制。FIFO 队列按先进先出原则传送消息，并确保仅处理一次。

### 持久性和可用性

在多个服务器上分布队列。冗余基础设施确保了对消息的高度并发访问。

### 安全性

保护传输中的数据和静态数据。通过加密队列传输敏感数据。在 Virtual Private Cloud 中发送消息。	

### 批处理

批量发送、接收或删除消息，每批最多 10 条消息或 256KB。



# SQS用法

spring 读取配置文件

```java
import com.amazonaws.regions.Regions;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@Validated
@ConfigurationProperties("aws.credentials")
@Data
public class AwsCredentialsProperties {
    @NotBlank private String accessKey;
    @NotBlank private String secretKey;
    @NotNull private Regions region;
}
```

设置用于开发的 AWS 凭证和区域 将读取到的配置文件填入snsClient中，注入一个bean

```java
import info.xiamo.property.AwsCredentialsProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.sns.SnsClient;

@Configuration
public class AwsSnsConfiguration {

    @Bean
    public SnsClient sqsClient(AwsCredentialsProperties awsCredentialsProperties) {
        AwsBasicCredentials credentials =
                AwsBasicCredentials.create(
                        awsCredentialsProperties.getAccessKey(),
                        awsCredentialsProperties.getSecretKey());

        StaticCredentialsProvider credentialsProvider =
                StaticCredentialsProvider.create(credentials);

        String name = awsCredentialsProperties.getRegion().name();
        return SnsClient.builder()
                .region(Region.of(name))
                .credentialsProvider(credentialsProvider)
                .build();
    }
}


```



```java
import info.xiaomo.property.AwsCredentialsProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.sqs.SqsClient;

@Configuration
public class AwsSqsConfiguration {

    @Bean
    public SqsClient sqsClient(AwsCredentialsProperties awsCredentialsProperties) {
        return SqsClient.builder()
            .region(Region.of(awsCredentialsProperties.getRegion().getName()))
                .credentialsProvider(
                        StaticCredentialsProvider.create(
                                AwsBasicCredentials.create(
                                        awsCredentialsProperties.getAccessKey(),
                                        awsCredentialsProperties.getSecretKey())))
                .build();
    }
}
```





```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import software.amazon.awssdk.services.sqs.SqsClient;
import software.amazon.awssdk.services.sqs.model.*;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.StringWriter;
import java.util.*;

@Component
public class AwsSqsClient {

    private final String QUEUE_NAME = "clearCacheQueue";

    @Autowired
    private SqsClient sqsClient;

    /** 清除消息队列 */
    public void purgeMyQueue() {
        GetQueueUrlRequest getQueueRequest =
                GetQueueUrlRequest.builder().queueName(QUEUE_NAME).build();

        PurgeQueueRequest queueRequest =
                PurgeQueueRequest.builder()
                        .queueUrl(sqsClient.getQueueUrl(getQueueRequest).queueUrl())
                        .build();

        sqsClient.purgeQueue(queueRequest);
    }

    /**
     * 获取消息
     *
     * @return String
     */
    public String getMessages() {
        List<String> attr = new ArrayList<>();
        attr.add("Name");

        try {

            GetQueueUrlRequest getQueueRequest =
                    GetQueueUrlRequest.builder().queueName(QUEUE_NAME).build();

            String queueUrl = sqsClient.getQueueUrl(getQueueRequest).queueUrl();

            ReceiveMessageRequest receiveRequest =
                    ReceiveMessageRequest.builder()
                            .queueUrl(queueUrl)
                            .maxNumberOfMessages(10)
                            .messageAttributeNames(attr)
                            .build();
            List<Message> messages = sqsClient.receiveMessage(receiveRequest).messages();

            SqsMessage myMessage;

            List<SqsMessage> allMessages = new ArrayList<>();

            for (Message m : messages) {

                myMessage = new SqsMessage();
                myMessage.setBody(m.body());

                Map<String, MessageAttributeValue> map = m.messageAttributes();
                MessageAttributeValue val = map.get("Name");
                myMessage.setName(val.stringValue());

                allMessages.add(myMessage);
            }

            return convertToString(toXml(allMessages));

        } catch (SqsException e) {
            e.getStackTrace();
        }
        return "";
    }

    public void processMessage(SqsMessage msg) {
        try {
            MessageAttributeValue attributeValue =
                    MessageAttributeValue.builder()
                            .stringValue(msg.getName())
                            .dataType("String")
                            .build();

            Map<String, MessageAttributeValue> myMap = new HashMap<>();
            myMap.put("Name", attributeValue);

            GetQueueUrlRequest getQueueRequest =
                    GetQueueUrlRequest.builder().queueName(QUEUE_NAME).build();

            String queueUrl = sqsClient.getQueueUrl(getQueueRequest).queueUrl();

            UUID uuid = UUID.randomUUID();
            String msgId1 = uuid.toString();

            SendMessageRequest sendMsgRequest =
                    SendMessageRequest.builder()
                            .queueUrl(queueUrl)
                            .messageAttributes(myMap)
                            .messageGroupId("GroupA")
                            .messageDeduplicationId(msgId1)
                            .messageBody(msg.getBody())
                            .build();
            sqsClient.sendMessage(sendMsgRequest);

        } catch (SqsException e) {
            e.getStackTrace();
        }
    }

    private Document toXml(List<SqsMessage> itemList) {

        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.newDocument();

            Element root = doc.createElement("Messages");
            doc.appendChild(root);

            for (SqsMessage myMessage : itemList) {

                Element item = doc.createElement("Message");
                root.appendChild(item);

                Element id = doc.createElement("Data");
                id.appendChild(doc.createTextNode(myMessage.getBody()));
                item.appendChild(id);

                Element name = doc.createElement("User");
                name.appendChild(doc.createTextNode(myMessage.getName()));
                item.appendChild(name);
            }

            return doc;
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String convertToString(Document xml) {
        try {
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            StreamResult result = new StreamResult(new StringWriter());
            DOMSource source = new DOMSource(xml);
            transformer.transform(source, result);
            return result.getWriter().toString();

        } catch (TransformerException ex) {
            ex.printStackTrace();
        }
        return null;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    static class SqsMessage {
        private String id;
        private String body;
        private String name;
    }
}
```

# SNS 是什么

SNS(Simple Notification Service)是发布/订阅主题的消息托管消息收发服务，可让您将发布者与订阅者分离。这对于用于微服务、分布式架构和无服务器应用程序的系统到系统消息收发很有用。

![sns-how-works](https://image.xiaomo.info//blog/sns-how-works.png)

# SNS作用

Amazon SNS 可让您将推送通知发送到移动应用程序，将文本消息发送到电话号码，并将纯文本电子邮件发送到电子邮件地址。您可以通过主题来散发消息，或直接将消息发布到移动终端节点。



# SQS VS SNS 区别

Amazon SQS 和 Amazon SNS 都是 AWS 中的消息发送服务，但为开发人员提供了不同的优势。Amazon SNS 允许应用程序通过“推送”机制向多个订阅者发送时间关键型消息，并且无需定期检查或“轮询”更新。Amazon SQS 是供分布式应用程序使用的消息队列服务，它通过轮询模式交换消息，可用于解耦收发组件。Amazon SQS 使应用程序的分布式组件可以灵活地收发消息，并且不要求每个组件同时可用。

SNS重点在推送，需要接收组件同时可用

SQS更多是一个消息队列服务，需要使用组件通过轮询模式交换消息，不要求每个组件同时可用



# 为什么使用SNS而不是MQ

我们现有的服务重度依赖于AWS，包括但不限于[EC2](https://ap-northeast-1.console.aws.amazon.com/ec2/v2/home?region=ap-northeast-1), [Lambda](https://ap-northeast-1.console.aws.amazon.com/lambda/home?region=ap-northeast-1), [EC2 Image Builder](https://ap-northeast-1.console.aws.amazon.com/imagebuilder/home?region=ap-northeast-1), [Elastic Container Service](https://ap-northeast-1.console.aws.amazon.com/ecs/home?region=ap-northeast-1),[CloudWatch](https://ap-northeast-1.console.aws.amazon.com/cloudwatch/home?region=ap-northeast-1),[Simple Notification Service](https://ap-northeast-1.console.aws.amazon.com/sns/home?region=ap-northeast-1),[AWS Single Sign-On](https://ap-northeast-1.console.aws.amazon.com/singlesignon/home?region=ap-northeast-1) ，如果aws有对应的服务会优先使用。虽然aws也有[Amazon MQ](https://ap-northeast-1.console.aws.amazon.com/amazon-mq/home?region=ap-northeast-1)，但是NSQ天生具有很好的扩展性。rabbitmq稍微差一些，但是如果自己高一个类似nsqlookupd的程序来维护rabbitmq上的数据，还是可以做的。NSQ在这方面优势明显，基本都是现成的。rabbitmq需要额外开发服务器端的程序或者对amqp协议做自己的封装。基本上NSQ只要维护好几个公共的nsqlookup节点，剩下的只要将nsqd做成一个镜像。处理节点本身可以被云计算的autoscaling服务维护。额外说明：rabbitmq是用erlang写的，运行需要erlang环境会更加占内存一些。消息处理效率上两者相差也不会太大。监控上两者都有独立的API接口可以导出队列信息。



# SNS用法

[pdf文档](https://docs.aws.amazon.com/zh_cn/sns/latest/dg/sns-dg.pdf#welcome)





## sns 命令行

您可以使用 AWS Command Line Interface (AWS CLI) 访问 Amazon Simple Notification Service (Amazon SNS) 的功能。要列出 Amazon SNS 的 AWS CLI 命令，请使用以下命令。

```
aws sns help
```

在运行任何命令之前，请设置默认证书。有关更多信息，请参阅 [配置 AWS CLI](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-chap-configure.html)。

本主题显示执行 Amazon SNS 常见任务的 CLI 命令。

**主题**

-   [创建主题](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-services-sns.html#cli-create-sns-topic)
-   [订阅主题](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-services-sns.html#cli-subscribe-sns-topic)
-   [向主题发布](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-services-sns.html#cli-publish-sns-topic)
-   [取消订阅主题](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-services-sns.html#cli-unsubscribe-sns-topic)
-   [删除主题](https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-services-sns.html#cli-delete-sns-topic)



## 创建主题

要创建主题，请使用 [`create-topic`](https://docs.aws.amazon.com/cli/latest/reference/sns/create-topic.html) 命令并指定要分配给该主题的名称。

```
$ aws sns create-topic --name my-topic
{
    "TopicArn": "arn:aws:sns:us-west-2:123456789012:my-topic"
}
```

记下响应的 `TopicArn`，您随后将用它来发布消息。



## 订阅主题

要订阅主题，请使用 [`subscribe`](https://docs.aws.amazon.com/cli/latest/reference/sns/subscribe.html) 命令。

以下示例为 `notification-endpoint` 指定 `email` 协议和电子邮件地址。

```
$ aws sns subscribe --topic-arn arn:aws:sns:us-west-2:123456789012:my-topic --protocol email --notification-endpoint saanvi@example.com
{
    "SubscriptionArn": "pending confirmation"
}
```

AWS 通过向您在 `subscribe` 命令中指定的地址发送电子邮件，立即发送确认电子邮件。电子邮件具有以下文本。

```
You have chosen to subscribe to the topic:
arn:aws:sns:us-west-2:123456789012:my-topic
To confirm this subscription, click or visit the following link (If this was in error no action is necessary):
Confirm subscription
```

收件人单击**确认订阅**链接后，收件人的浏览器显示通知消息，信息类似于以下内容。

```
Subscription confirmed!

You have subscribed saanvi@example.com to the topic:my-topic.

Your subscription's id is:
arn:aws:sns:us-west-2:123456789012:my-topic:1328f057-de93-4c15-512e-8bb22EXAMPLE

If it was not your intention to subscribe, click here to unsubscribe.
```



## 向主题发布

要将消息发送给某一主题的所有订阅者，请使用 [publish](https://docs.aws.amazon.com/cli/latest/reference/sns/publish.html) 命令。

以下示例向指定主题的所有订阅者发送消息“Hello World!”。

```
$ aws sns publish --topic-arn arn:aws:sns:us-west-2:123456789012:my-topic --message "Hello World!"
{
    "MessageId": "4e41661d-5eec-5ddf-8dab-2c867EXAMPLE"
}
```

在本示例中，AWS 将包含文本“Hello World!”的电子邮件发送到 `saanvi@example.com`。



## 取消订阅主题

要取消订阅某个主题并停止接收向该主题发布的消息，请使用 [unsubscribe](https://docs.aws.amazon.com/cli/latest/reference/sns/unsubscribe.html) 命令并指定您要取消订阅的主题的 ARN。

```
$ aws sns unsubscribe --subscription-arn arn:aws:sns:us-west-2:123456789012:my-topic:1328f057-de93-4c15-512e-8bb22EXAMPLE
```

要验证您已成功取消订阅，请使用 [list-subscriptions](https://docs.aws.amazon.com/cli/latest/reference/sns/list-subscriptions.html) 命令以确认该 ARN 不再显示在列表中。

```
$ aws sns list-subscriptions
```



## 删除主题

要删除主题，请运行 [delete-topic](https://docs.aws.amazon.com/cli/latest/reference/sns/delete-topic.html) 命令。

```
$ aws sns delete-topic --topic-arn arn:aws:sns:us-west-2:123456789012:my-topic
```

要验证 AWS 已成功删除主题，请使用 [list-topics](https://docs.aws.amazon.com/cli/latest/reference/sns/list-topics.html) 命令以确认该主题不再显示在列表中。

```
$ aws sns list-topics
```





## java集成SNS(警告触发)

gradle

```kotlin
    implementation ("software.amazon.awssdk:sns:2.15.19")
```



maven

```xml
<!-- https://mvnrepository.com/artifact/software.amazon.awssdk/sns -->
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>sns</artifactId>
    <version>2.15.19</version>
    <scope>test</scope>
</dependency>

```



yaml配置文件

```yml
// application.yml 配置文件
aws:
  credentials:
    region: ap_northeast_1
    accessKey: your accessKey
    secretKey: you secretKey
```



spring 读取配置文件

```java
import com.amazonaws.regions.Regions;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@Validated
@ConfigurationProperties("aws.credentials")
@Data
public class AwsCredentialsProperties {
    @NotBlank private String accessKey;
    @NotBlank private String secretKey;
    @NotNull private Regions region;
}
```

设置用于开发的 AWS 凭证和区域 将读取到的配置文件填入snsClient中，注入一个bean

```java
import info.xiamo.property.AwsCredentialsProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.sns.SnsClient;

@Configuration
public class AwsSnsConfiguration {

    @Bean
    public SnsClient snsClient(AwsCredentialsProperties awsCredentialsProperties) {
        AwsBasicCredentials credentials =
                AwsBasicCredentials.create(
                        awsCredentialsProperties.getAccessKey(),
                        awsCredentialsProperties.getSecretKey());

        StaticCredentialsProvider credentialsProvider =
                StaticCredentialsProvider.create(credentials);

        String name = awsCredentialsProperties.getRegion().getName();
        return SnsClient.builder()
                .region(Region.of(name))
                .credentialsProvider(credentialsProvider)
                .build();
    }
}
```



使用注册好的SsnsClient调用api

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import software.amazon.awssdk.services.sns.SnsClient;
import software.amazon.awssdk.services.sns.model.*;

import java.util.List;
import java.util.Map;

@Component
@Slf4j
public class AwsSnsClient {

    @Autowired private SnsClient snsClient;

    // 创建主题
  	//主题是通信通道的逻辑分组，可定义要将消息发送到的系统，例如，将消息发送到 AWS Lambda 和 HTTP Webhook。将消息发送到 Amazon SNS 之后，这些消息将分发到主题中定义的各个通道。这将使订阅者能够收到这些消息。要创建主题，请先构建一个 CreateTopicRequest 对象，并使用构建器中的 name() 方法设置主题的名称。然后，使用 SnsClient 的 createTopic() 方法将请求对象发送到 Amazon SNS。可以将此请求的结果作为 CreateTopicResponse 对象捕获，如以下代码段中所示。
    public String createSNSTopic(String topicName) {
        CreateTopicResponse result;
        try {
            CreateTopicRequest request = CreateTopicRequest.builder().name(topicName).build();

            result = snsClient.createTopic(request);
            return result.topicArn();
        } catch (SnsException e) {
            log.error("create sns topic error:{}", e.awsErrorDetails().errorMessage());
        }
        return null;
    }

   // 删除主题
   // 要删除 Amazon SNS 主题，请先构建一个 DeleteTopicRequest 对象，并将主题的 ARN 设置为构建器中的 topicArn() 方法。然后，使用 SnsClient 的 deleteTopic() 方法将请求对象发送到 Amazon SNS。可以将此请求的结果作为 DeleteTopicResponse 对象捕获，如以下代码段中所示。
    public DeleteTopicResponse deleteSNSTopic(String topicArn) {
        try {
            DeleteTopicRequest request = DeleteTopicRequest.builder().topicArn(topicArn).build();

            DeleteTopicResponse result = snsClient.deleteTopic(request);
            return result;

        } catch (SnsException e) {
            log.error("delete sns topic error:{}", e.awsErrorDetails().errorMessage());
        }
        return null;
    }

    public Map<String, String> getSNSAttributes(String topicArn) {

        try {
            GetSubscriptionAttributesRequest request =
                    GetSubscriptionAttributesRequest.builder().subscriptionArn(topicArn).build();

            GetSubscriptionAttributesResponse res = snsClient.getSubscriptionAttributes(request);
            return res.attributes();

        } catch (SnsException e) {
            log.error("get sns attribute error:{}", e.awsErrorDetails().errorMessage());
        }
        return null;
    }

  // 获取sns属性
    public Map<String, String> getSNSTopicAttributes(String topicArn) {

        try {
            GetTopicAttributesRequest request =
                    GetTopicAttributesRequest.builder().topicArn(topicArn).build();

            GetTopicAttributesResponse result = snsClient.getTopicAttributes(request);
            return result.attributes();

        } catch (SnsException e) {
            log.error("get sns topic attributes error:{}", e.awsErrorDetails().errorMessage());
            return null;
        }
    }

    public List<Subscription> listSNSSubscriptions() {
        try {
            ListSubscriptionsRequest request = ListSubscriptionsRequest.builder().build();
            ListSubscriptionsResponse result = snsClient.listSubscriptions(request);
            return result.subscriptions();

        } catch (SnsException e) {
            log.error("list sns subscriptions error:{}", e.awsErrorDetails().errorMessage());
            return null;
        }
    }

  	// 展示主题列表
  	// 要检索现有 Amazon SNS 主题的列表，请构建一个 ListTopicsRequest 对象。然后，使用 SnsClient 的 listTopics() 方法将请求对象发送到 Amazon SNS。可以将此请求的结果作为 ListTopicsResponse 对象捕获。以下代码段输出请求的 HTTP 状态代码以及您的 Amazon SNS 主题的 Amazon 资源名称 (ARN) 列表。
    public List<Topic> listSNSTopics() {
        try {
            ListTopicsRequest request = ListTopicsRequest.builder().build();

            ListTopicsResponse result = snsClient.listTopics(request);
            log.info(
                    "Status was {} Topics :{}",
                    result.sdkHttpResponse().statusCode(),
                    result.topics());

            return result.topics();
        } catch (SnsException e) {
            log.error("list sns topics error: {}", e.awsErrorDetails().errorMessage());
            return null;
        }
    }

 		// 发布消息
  	// 如果您拥有一个主题并且已为该主题配置一个或多个终端节点，则可向该主题发布消息。首先，请构建一个 PublishRequest 对象。指定要发送的 message()，并指定要将消息发送到的主题的 ARN (topicArn())。然后，使用 SnsClient 的 publish() 方法将请求对象发送到 Amazon SNS。可以将此请求的结果作为 PublishResponse 对象捕获。
    public PublishResponse publishTopic(String message, String topicArn) {
        try {
            PublishRequest request =
                    PublishRequest.builder().message(message).topicArn(topicArn).build();

            return snsClient.publish(request);

        } catch (SnsException e) {
            log.error("public topic error:{}", e.awsErrorDetails().errorMessage());
            return null;
        }
    }

  // 订阅https
  // 创建主题后，您可以配置将哪些通信通道作为该主题的终端节点。在 Amazon SNS 收到消息后，消息将分发给这些终端节点。要将通信通道配置为主题的终端节点，请为该终端节点订阅主题。首先，请构建一个 SubscribeRequest 对象。将通信通道（例如，lambda 或 email）指定为 protocol()。将 endpoint() 设置为相关输出位置（例如，Lambda 函数的 ARN 或电子邮件地址），然后将要订阅的主题的 ARN 设置为 topicArn()。然后，使用 SnsClient 的 subscribe() 方法将请求对象发送到 SNS。可以将此请求的结果作为 SubscribeResponse 对象捕获。

以下代码段说明如何为电子邮件地址订阅主题。
    public SubscribeResponse subscribeHttps(String topicArn, String url) {

        try {
            SubscribeRequest request =
                    SubscribeRequest.builder()
                            .protocol("https")
                            .endpoint(url)
                            .returnSubscriptionArn(true)
                            .topicArn(topicArn)
                            .build();

            return snsClient.subscribe(request);

        } catch (SnsException e) {
            log.error("subscribe https error:{}", e.awsErrorDetails().errorMessage());
            return null;
        }
    }

  // 取消订阅
	// 可以删除配置为主题的终端节点的通信通道。执行此操作后，主题本身将继续存在，并会将消息分发到为该主题配置的任何其他终端节点。要删除作为主题的终端节点的通信通道，请为该终端节点取消订阅主题。首先，请构建一个 UnsubscribeRequest 对象，并将要取消订阅的主题的 ARN 设置为 subscriptionArn()。然后，使用 SnsClient 的 unsubscribe() 方法将请求对象发送到 SNS。可以将此请求的结果作为 UnsubscribeResponse 对象捕获。
    public UnsubscribeResponse unSubscription(String subscriptionToken) {
        try {
            UnsubscribeRequest request =
                    UnsubscribeRequest.builder().subscriptionArn(subscriptionToken).build();
            return snsClient.unsubscribe(request);
        } catch (SnsException e) {
            log.error("unSubscription error:{}", e.awsErrorDetails().errorMessage());
            return null;
        }
    }
}
```



在controller中注入并测试

```java
import info.xiaomo.client.AwsSnsClient;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import software.amazon.awssdk.services.sns.model.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/sns")
@Slf4j
public class SnsController {

    private static final String TOPIC_NAME = "clear-cache";

    @Autowired private AwsSnsClient awsSnsClient;

    /**
     * 查询所有的主题
     *
     * @return 主题列表
     */
    @RequestMapping("/listSNSTopics")
    public List<Topic> listSNSTopics() {
        return awsSnsClient.listSNSTopics();
    }

    /**
     * 查询所有的订阅
     *
     * @return 订阅列表
     */
    @RequestMapping("/listSnsSubscriptions")
    public List<Subscription> listSnsSubscriptions() {
        return awsSnsClient.listSNSSubscriptions();
    }

    /**
     * 创建主题
     *
     * @return CreateTopicResponse
     */
    @RequestMapping("/createSnsTopic")
    public CreateTopicResponse createSnsTopic() {
        return awsSnsClient.createSNSTopic(TOPIC_NAME);
    }

    /**
     * 删除主题
     *
     * @return 删除结果
     */
    @RequestMapping("/deleteSnsTopic")
    public boolean deleteSnsTopic() {
        DeleteTopicResponse deleteTopicResponse = awsSnsClient.deleteSNSTopic(TOPIC_NAME);
        return deleteTopicResponse.sdkHttpResponse().isSuccessful();
    }

    /**
     * 发布主题 如果您拥有一个主题并且已为该主题配置一个或多个终端节点，则可向该主题发布消息。
     *
     * @param message message
     * @return message
     */
    @RequestMapping("/publishTopic")
    public PublishResponse publishTopic(String message) {
        return awsSnsClient.publishTopic(message, TOPIC_NAME);
    }

    /**
     * 订阅 创建主题后，您可以配置将哪些通信通道作为该主题的终端节点。在 Amazon SNS 收到消息后，消息将分发给这些终端节点。
     *
     * @param url url
     * @return SubscribeResponse
     */
    @RequestMapping("/subscribe/{url}")
    public SubscribeResponse subscribe(@PathVariable String url) {
        return awsSnsClient.subscribeHttps(TOPIC_NAME, url);
    }

    /**
     * 取消订阅
     *
     * @param subscriptionToken subscriptionToken
     * @return 是否取消成功
     */
    @RequestMapping("/unSubscribe/{subscriptionToken}")
    public boolean unSubscribe(@PathVariable String subscriptionToken) {
        UnsubscribeResponse unsubscribeResponse = awsSnsClient.unSubscription(subscriptionToken);
        return unsubscribeResponse.sdkHttpResponse().isSuccessful();
    }

    /**
     * 查询所有的属性
     *
     * @return 属性Map
     */
    @RequestMapping("/getSNSAttributes")
    public Map<String, String> getSNSAttributes() {
        return awsSnsClient.getSNSAttributes(TOPIC_NAME);
    }

    /**
     * 查询主题的属性
     *
     * @return 主题属性Map
     */
    @RequestMapping("/getSNSTopicAttributes")
    public Map<String, String> getSNSTopicAttributes() {
        return awsSnsClient.getSNSTopicAttributes(TOPIC_NAME);
    }

    /** 测试 */
    @RequestMapping("")
    public void test() {
        List<Topic> topics = awsSnsClient.listSNSTopics();
        List<Subscription> subscriptions = awsSnsClient.listSNSSubscriptions();
        System.out.println(topics);
        System.out.println(subscriptions);

        String topicName = "clearCacheTopic";
        String topic = awsSnsClient.createSNSTopic(topicName).topicArn();
        System.out.println(topic);

        awsSnsClient.subscribeHttps(topicName, "xxx");

        PublishResponse publishResponse = awsSnsClient.publishTopic("hello", topicName);
        if (publishResponse != null) {
            System.out.println(publishResponse.messageId());
        }

        UnsubscribeResponse unsubscribeResponse = awsSnsClient.unSubscription("1123");
        if (unsubscribeResponse != null) {
            System.out.println(unsubscribeResponse.sdkHttpResponse().statusCode());
        }

        Map<String, String> clearCacheTopic = awsSnsClient.getSNSAttributes(topicName);
        for (String value : clearCacheTopic.values()) {
            System.out.println(value);
        }

        DeleteTopicResponse deleteTopicResponse = awsSnsClient.deleteSNSTopic(topicName);
        System.out.println(deleteTopicResponse.toString());

        Map<String, String> attributes = awsSnsClient.getSNSTopicAttributes(topicName);
        for (String value : attributes.values()) {
            log.info(value);
        }
    }
}

```