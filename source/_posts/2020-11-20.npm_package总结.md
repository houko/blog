---
author: 小莫
date: 2020-12-04
title: npm优秀库使用收集整理(长期向)
tags:
- npm
category: web
permalink: npmPackageCollection
---

虽然自栩全沾工程师，但是对于前端圈的了解还是相对缺乏的，尤其是大量的npm包。java的maven/gradle， node的npm， swift的pod,，python的pip，php的Composer，c++的[Conan](https://github.com/conan-io/conan)等等。基本上每一种开发语言都有自己的包管理器。开源三方库汇集了全世界的智慧结晶，有了这些优秀的三方库能够让我们很容易的完成复杂的功能。所以打算开一个长期向的优秀库的使用收集博客。大部分内容是搜索到的优秀博文整理而来。

<!-- more -->

注： 本篇文章开始于2020年11月20，每次修改或新增时都会将时间更新时最新的时间，每个库的使用也会标注版本和来源。



# ajv(v6.12.6)

#### 作用 

ajv 是一个非常流行的JSON Schema验证工具，并且拥有非常出众的性能表现。下方的例子中，我们使用ajv来验证用户输入的表单数据是否合法。

```js
const Ajv = require('ajv');

let schema = {
  type: 'object',
  required: ['username', 'email', 'password'],
  properties: {
    username: {
      type: 'string',
      minLength: 4
    },
    email: {
      type: 'string',
      format: 'email'
    },
    password: {
      type: 'string',
      minLength: 6
    },
    age: {
      type: 'integer',
      minimum: 0
    },
    sex: {
      enum: ['boy', 'girl', 'secret'],
      default: 'secret'
    },
  }
};

let ajv = new Ajv();
let validate = ajv.compile(schema);

let valid = validate(data);
if (!valid) console.log(validate.errors);
```

在上述代码中，我们声明了一个数据模式`schema` ，这个模式要求目标数据为一个对象，对象可以有五个字段 `username`、`email`、`password`、`age`、`sex`，并分别定义了五个字段的类型和数据格式要求，并且其中 `username`、`email`、`password` 必填。然后我们使用这个模式去验证用户输入的数据 `data` 是否满足我们的需求。

注意：

1. JSON Schema 是一个声明模式描述对象的标准，并非一个库

2. ajv 是一个JSON Schema标准验证器的实现，除了ajv还有很多其他的库

3. 代码中的 `schema` 是使用 JSON Schema 生成的模式描述对象

4.  代码中 `data` 是我们要进行检查的数据



#### 参考资料

JSON Schema [http://json-schema.org](http://json-schema.org/)

AJV [https://github.com/epoberezkin/ajv](https://github.com/epoberezkin/ajv)    



来源: https://segmentfault.com/a/1190000013265287    



# accounting(0.4.2)

#### 作用

accounting是用来格式化数字的库， 主要提供的方法有 `formatMoney()` `formatColumn()` `formatNumber()` `toFixed()` `unformat()`



接下来我们一一介绍：

#### formatMoney() 格式化货币

```js
// 默认货币格式：货币符号$，保留两位小数，每千位加逗号
accounting.formatMoney(12345678); // $12,345,678.00

// 指定货币符号、保留小数位、千位间隔符
accounting.formatMoney(12345678, '￥', 2, ''); // ￥12345678.00
```

#### formatColumn() 格式化并按列对其

在制表时，`formatColumn()` 方法方便我们按照表格列对齐数字和货币符号：

```js
accounting.formatColumn([123.5, 3456.615, 777888.99, -5432, -1234567, 0], "$ ");
```

格式化后的效果：

![图片描述](https://image.xiaomo.info//blog/bV3yyE.png)

#### formatNumber() 格式化数字

```js
accounting.formatNumber(5318008); // 5,318,008
accounting.formatNumber(9876543.21, 3, " "); // 9 876 543.210
```

#### toFixed() 保留小数位

和JavaScript内置 `Number.prototype.toFixed()` 不同的是，`accounting.toFixed()` 有四舍五入的效果：

```js
(0.615).toFixed(2); // "0.61"
accounting.toFixed(0.615, 2); // "0.62"
```

#### unformat() 解析数字

`unformat()` 方法能够从任何格式的字符串中解析出原始数字：

```js
accounting.unformat("£ 12,345,678.90 GBP"); // 12345678.9
```

#### 参考资料

[http://openexchangerates.github.io/accounting.js/](http://openexchangerates.github.io/accounting.js/)

[https://github.com/openexchangerates/accounting.js](https://github.com/openexchangerates/accounting.js)    



来源: https://segmentfault.com/a/1190000013201803



# async-retry(1.3.1)

#### 作用

异步的执行对某个操作的重试，可以设置重试次数。



使用demo

```js
// Packages
const retry = require('async-retry')
const fetch = require('node-fetch')
 
await retry(async bail => {
  // if anything throws, we retry
  const res = await fetch('https://google.com')
 
  if (403 === res.status) {
    // don't retry upon 403
    bail(new Error('Unauthorized'))
    return
  }
 
  const data = await res.text()
  return data.substr(0, 500)
}, {
  retries: 5
})
```



说明：

1.  提供的功能可以是async或不是。换句话说，它可以是返回Promise或值的函数。

2. 提供的函数接收两个参数

```java
Function您可以调用A以中止重试（保释）

Number识别尝试。绝对的首次尝试（在重试之前）为1。
```

3. 将opts被传递到node-retry。阅读[其文档](https://github.com/tim-kos/node-retry)

4.  retries：重试该操作的最大次数。默认值为10。
5.  factor：要使用的指数因子。默认值为2。
6.  minTimeout：开始第一次重试之前的毫秒数。默认值为1000。
7.  maxTimeout：两次重试之间的最大毫秒数。默认值为Infinity。
8.  randomize：通过乘以介于之间的因数1来随机化超时2。默认值为true。
9.  onRetry：可选Function，在执行新的重试后调用。它传递了Error触发它的参数。



# chalk(4.1.0)

将在终端中输出蓝色带下划线的MCC。

![chalk](https://image.xiaomo.info//blog/chalk.png)

`echo -e "\e[34;4mMCC\e[0m" `

虽然我们已经学会了，在终端中控制字符颜色的原理和方法，但是这种操作太过于繁琐，每一次都需要查颜色样式手册，然后写出一堆无法阅读的火星文，抓狂！

今天介绍的NPM库chalk就是用来优雅地输出带颜色的文本，**不需要记忆、查阅样式手册**。

## 安装

`npm install chalk `

```js
const ctx = new chalk.Instance({level: 0});
```

| Level | Description                           |
| :---: | :------------------------------------ |
|  `0`  | All colors disabled                   |
|  `1`  | Basic color support (16 colors)       |
|  `2`  | 256 color support                     |
|  `3`  | Truecolor support (16 million colors) |



## 使用

chalk 将各种颜色和样式修饰符实现为各个函数，并且支持链式调用。

```js
 const chalk = require('chalk');          

// 输出蓝色的MCC     

console.log(chalk.blue('MCC'));         

 // 输出蓝色带下划线的MCC     

console.log(chalk.blue.underline('MCC'));    

 // 使用RGB颜色输出  

console.log(chalk.rgb(4,  156, 219).underline('MCC'));     

console.log(chalk.hex('#049CDB').bold('MCC'));     

console.log(chalk.bgHex('#049CDB').bold('MCC'));   
```



### 效果

![image-20201204181923326](https://image.xiaomo.info//blog/image-20201204181923326.png)



### 文本样式修饰符函数

```
reset 重置样式    

bold 加粗    

dim 昏暗    

italic 斜体    

underline 下划线    

inverse 反色    

hidden 隐藏    

strikethrough 删除线    

visible 可见   
```

​    

### 颜色函数

```
black    

red    

green    

yellow    

blue    

magenta    

cyan    

white    

gray ("bright black")    

redBright    

greenBright    

yellowBright    

blueBright    

magentaBright    

cyanBright    

whiteBright
```

​       

#### 背景色函数

```js
bgBlack    

bgRed    

bgGreen    

bgYellow    

bgBlue    

bgMagenta    

bgCyan    

bgWhite    

bgBlackBright    

bgRedBright    

bgGreenBright    

bgYellowBright    

bgBlueBright    

bgMagentaBright    

bgCyanBright    

bgWhiteBright 
```

​      

#### 源码

https://github.com/chalk/chalk



# ora(5.1.0)

优雅的转圈圈,让你的等待不再煎熬～

![ora](https://image.xiaomo.info//blog/ora.gif)

`yarn add ora`



使用

```js
const ora = require('ora');

const spinner = ora('Loading unicorns').start();

setTimeout(() => {
	spinner.color = 'yellow';
	spinner.text = 'Loading rainbows';
}, 1000);
```



https://github.com/sindresorhus/ora



# figlet(1.5.0)

`yarn add figlet`



使用

```js
    figlet('Hello World!!', function(err, data) {
        if (err) {
            console.log('Something went wrong...');
            console.dir(err);
            return;
        }
        console.log(data)
    });
```



效果

![image-20201204182909081](https://image.xiaomo.info//blog/image-20201204182909081.png)



# boxen(4.2.0)

给你的代码画上界限,守护自己的地盘～

`yarn add boxen`



使用

```js
const boxen = require('boxen');

console.log(boxen('unicorn', {padding: 1}));
```



效果

![image-20201204183307440](https://image.xiaomo.info//blog/image-20201204183307440.png)



https://github.com/sindresorhus/boxen



# classnames（2.2.6）

快速的组合class name



在前端开发中，我们经常需要JS来判断生成DOM节点CSS类，比如：

```js
let className='btn-primary';
if(active){
  className+=' active';
}
return <div className={className}>Save</div>; 
```

在上述代码中，我们需要判断active变量来控制生成的按钮的CSS样式是否是激活状态，在实际开发中，可能会有更多的类似这样的样式控制逻辑，从而干扰阅读业务逻辑代码，使得代码变得很“脏”。
classnames
classnames 库对CSS样式类操作进行了封装，方便我们快速使用：

```js
const classNames = require('classnames');

//...

return <div className={classNames('btn-primary',{ active })}>Save</div>; 
```

更多调用方式：

```js
classNames('foo', 'bar'); // => 'foo bar' 
classNames('foo', { bar: true }); // => 'foo bar' 
classNames({ 'foo-bar': true }); // => 'foo-bar' 
classNames({ 'foo-bar': false }); // => '' 
classNames({ foo: true }, { bar: true }); // => 'foo bar' 
classNames({ foo: true, bar: true }); // => 'foo bar' 
```

https://github.com/JedWatson/classnames



# concurrently（5.3.0）

主要是方便我们写前端工程化的时候，我们可以同时启动多个命令用。
比如我的前端代码运行起来，既要有一个web工程，同时又要启动一个mock进程。这时候我们就可以使用这个并行解决方案。
文档地址：https://www.npmjs.com/package/concurrently
github地址：https://github.com/kimmobrunfeldt/concurrently

全局安装
`npm install concurrently -g`



项目安装
`npm install concurrently -D`



以上果是开发阶段写工具用的时候的安装方法。
如果比如node项目在生产环境使用则用以下安装方法：
`npm install concurrently -s`

三、使用方法
3.1 命令行使用方式
语法:
`concurrently "command1 arg" "command2 arg"`

比如我要启动两个node程序:

然后当我们ctrl + c后，他就会把两个进程都停止了。



方式1：
如果我们在package.json里面则要注意引号的问题:
`"start": "concurrently \"command1 arg\" \"command2 arg\""`
就是将"变成\".
方式2：

然后我们要让这个进行并行有两个方式，在命令行执行:

或者:

这块-n之后的两个单词，只能用,间隔，不能加空格。
方式三：
如果我们的package.json里面有以下三个watch类型的

```json
{
    //...
    "scripts": {
        // ...
        "watch-js": "...",
        "watch-css": "...",
        "watch-node": "...",
        // ...
    },
    // ...
}
```

那可以批量执行的方式:
`concurrently "npm:watch-*"`

我们可以书写一个node程序来调用concurrently。
我们写一个main.js的代码

```js
var concurrently = require('concurrently');

concurrently(['npm:index', "npm:hello"]).then(()=>{
    console.log("success");
}, ()=>{
    console.log("fail")
});
```

然后它的效果，就是`concurrently "npm:index" "npm:hello"`

然后当我们按了ctrl + c之后，他会打出success.



上面的index和hello对应的代码是:
index:

```js
var koa = require('koa');
var axios = require('axios')

const app = new koa();

app.use(async (ctx, next)=>{
    ctx.body = (await axios.get("http://127.0.0.1:8001/hello")).data;
})

app.listen(8000)
hello:
var koa = require('koa');

const app = new koa();

app.use((ctx, next)=>{
    ctx.body = 'hello world2';
})

app.listen(8001)
```





3.2.2 构建失败场景
我们修改上面的hello的代码:

```js
// hello:
var koa = require('koa');

const app = new koa();

app.use((ctx, next)=>{
    ctx.body = 'hello world2';
})

process.exit(-1);
```

然后我们在运行"node ./main.js"
我们会看到报错，但是程序不会退出。

然后当我们再按ctrl + c后，效果如下：


所以得出一个结论：当我们有一个进程返回失败的话，总体会进入fail的callback中。


### 应用场景
开发工具
比如当我们跑npm run start的时候，我们同时需要让sass编译，同时webpack也要跑hot 模式，则这个使用可以使用concurrently运行这两个command。
这块我们可以查看grafana里面的前端代码中，关于工具这块代码查看一下就可以看到这块的使用。
grafana地址: https://github.com/grafana/grafana

### 常见需求
当一个进程起来失败，整体concurrently失败?

我们可以通过killOthers这个参数来解决。
这样当我们有一个程序失败，则直接进入fail callback。也就把所有进程关闭了。
6.2 当一个进程起来失败，但是有可能是跟另外进程有关，这时候需要尝试几次？

这种情况，如上比如npm:index能启动的，npm:hello不能启动，虽然试了三次npm:hello，一直失败，但整体最终不会退出，只有我们按ctrl + c才有用，相当于killOthers就失效了。



# cors(2.8.5)

CORS是一个node.js软件包，用于提供可用于通过各种选项启用[CORS](http://en.wikipedia.org/wiki/Cross-origin_resource_sharing)的[Connect](http://www.senchalabs.org/connect/) / [Express](http://expressjs.com/)中间件。



安装

`yarn add cors`



开启所有的CORS

```js
var express = require('express')
var cors = require('cors')
var app = express()
 
app.use(cors())
 
app.get('/products/:id', function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for all origins!'})
})
 
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
```



开启单路由的CORS

```js
var express = require('express')
var cors = require('cors')
var app = express()
 
app.get('/products/:id', cors(), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a Single Route'})
})
 
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
```



配置CORS

```js
var express = require('express')
var cors = require('cors')
var app = express()
 
var corsOptions = {
  origin: 'http://example.com',
  optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204
}
 
app.get('/products/:id', cors(corsOptions), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for only example.com.'})
})
 
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
```



配置多个跨域白名单

```js
var express = require('express')
var cors = require('cors')
var app = express()
 
var whitelist = ['http://example1.com', 'http://example2.com']
var corsOptions = {
  origin: function (origin, callback) {
    if (whitelist.indexOf(origin) !== -1) {
      callback(null, true)
    } else {
      callback(new Error('Not allowed by CORS'))
    }
  }
}
 
app.get('/products/:id', cors(corsOptions), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a whitelisted domain.'})
})
 
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
```



如果您不想阻止REST工具或服务器到服务器的请求，`!origin`请在源函数中添加一个检查，如下所示：

```js
var corsOptions = {
  origin: function (origin, callback) {
    if (whitelist.indexOf(origin) !== -1 || !origin) {
      callback(null, true)
    } else {
      callback(new Error('Not allowed by CORS'))
    }
  }
}
```



异步CORS

```js
var express = require('express')
var cors = require('cors')
var app = express()
 
var whitelist = ['http://example1.com', 'http://example2.com']
var corsOptionsDelegate = function (req, callback) {
  var corsOptions;
  if (whitelist.indexOf(req.header('Origin')) !== -1) {
    corsOptions = { origin: true } // reflect (enable) the requested origin in the CORS response
  } else {
    corsOptions = { origin: false } // disable CORS for this request
  }
  callback(null, corsOptions) // callback expects two parameters: error and options
}
 
app.get('/products/:id', cors(corsOptionsDelegate), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a whitelisted domain.'})
})
 
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
```

https://github.com/expressjs/cors#readme



# cross-env（7.0.3）

`NODE_ENV=production`像这样设置环境变量时，大多数Windows命令提示符找不到命令，我们使用跨平台环境时能够抹平这个不同。



#### 安装

`yarn add corss-env`



#### 使用

直接在原来的脚本前加上`corss-env`

```js
{
  "scripts": {
    "build": "cross-env NODE_ENV=production webpack --config build/webpack.config.js"
  }
}
```



# cssnao(4.1.10)



#### 什么是缩减（minification）？[#](https://www.cssnano.cn/docs/introduction#什么是缩减（minification）？)

缩减（minification）是指利用各种方法来 减少代码体积的过程。和 gzip 之类的保留 CSS 文件的原始语义（即无损失）的技术不同，缩减（minification） 天生是一个有损失的过程，例如，其中某些值可能会被替换为更简化的 等价语法，或者选择器被合并。

缩减（minification）步骤的最终结果是生成的代码将与 原始代码行为相同，但是某些部分被修改以 尽可能减少代码体积。

将 gzip 压缩和缩减（minification）相结合，可以最大限度的减少 文件体积，但是不要耳听为虚、眼见为实，为什么不去试试 [css-size](https://npmjs.org/package/css-size) ？ css-size 是一个专门对比缩减（minification）前后文件体积大小变化的模块。



####  cssnano 是什么？[#](https://www.cssnano.cn/docs/introduction#cssnano-是什么？)

cssnano 就是这样的一个缩减器，它使基于 [Node.js](https://nodejs.org/) 开发的。cssnano 是一个 [PostCSS](http://postcss.org/) 插件，可以添加到你的构建流程中，用于确保最终生成的 用于生产环境的 CSS 样式表文件尽可能的小。

如果你不了解什么是构建流程，没关系，我们在 [入门指南](https://www.cssnano.cn/guides/getting-started) 中做了讲解。



#### 这对我有什么好处？[#](https://www.cssnano.cn/docs/introduction#这对我有什么好处？)

##### 大量的代码优化[#](https://www.cssnano.cn/docs/introduction#大量的代码优化)

我们提供了众多不同的优化，从简单的 清除空白符到复杂的不同名称的同一 keyframes 的合并等。 更多信息请参考 [预设指南](https://www.cssnano.cn/guides/presets)。



##### 统一的 CSS 处理[#](https://www.cssnano.cn/docs/introduction#统一的-css-处理)

cssnano 基于 [PostCSS](http://postcss.org/) 来处理 CSS 代码。因为很多 现代化的 CSS 工具都是基于 [PostCSS](http://postcss.org/) 开发的，因此你可以把这些工具组合起来 并生成一棵单一的抽象语法树（AST）。这就意味着总的处理时间 减少了，因为 CSS 不再需要进行多次解析了。



##### 现代化的架构以及模块化[#](https://www.cssnano.cn/docs/introduction#现代化的架构以及模块化)

因为 cssnano 是基于 [PostCSS](http://postcss.org/) 的，因此我们可以将 cssnano 的功能拆解为多个 插件，每个插件只需负责执行一项小的优化即可。并且许多优化可以限定 到某一组特定的 CSS 属性上，这就比利用正则表达式对 CSS 做全局处理更加安全。



# dotenv(8.2.0)

我们经常需要Node.js程序运行时加载不同的配置，比如开发环境和生产环境的数据数据库配置就可能不一样，使process.env.DB_HOST 环境变量，可以在Node.js程序内部方便获取参数信息。但是，程序启动时，怎样将环境变量传递给程序，这可能会是一个相对麻烦的事情，因为这关系到操作系统层的配置问题。



安装

```bash
# with npm 
npm install dotenv
 
# or with Yarn 
yarn add dotenv
```



#### 配置文件

在项目根路径下新建`.env`文件

```properties
DB_HOST=localhost
DB_USER=root
DB_PASS=s1mpl3 
```



然后，在Node.js程序启动时运行：

```js
require('dotenv').config() 
```

接着，我们就可以在接下来的程序中方便地使用环境变量了：

```js
const db = require('db')
db.connect({
  host: process.env.DB_HOST,
  username: process.env.DB_USER,
  password: process.env.DB_PASS
}) 
```

因此，我们可以创建不同的配置文件并提并git，然后在开发的时候copy一份`local.env`到根路径重命名为`.env`就可以做本地开发了，线上部署同理。

![image-20201204190948866](https://image.xiaomo.info//blog/image-20201204190948866.png)

https://github.com/motdotla/dotenv#readme



# ini(1.3.5)

```ini
; this comment is being ignored
scope = global

[database]
user = dbuser
password = dbpassword
database = use_this_database

[paths.default]
datadir = /var/lib/data
array[] = first value
array[] = second value
array[] = third value
```



读取ini文件

```js
const ini = require('ini');
const fs = require('fs');

let config = ini.parse(fs.readFileSync('config.ini', 'utf-8')); 
```



写入ini文件

```js
var fs = require('fs')
  , ini = require('ini')

var config = ini.parse(fs.readFileSync('./config.ini', 'utf-8'))

config.scope = 'local'
config.database.database = 'use_another_database'
config.paths.default.tmpdir = '/tmp'
delete config.paths.default.datadir
config.paths.default.array.push('fourth value')

fs.writeFileSync('./config_modified.ini', ini.stringify(config, { section: 'section' }))
```

https://github.com/npm/ini

