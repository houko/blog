---
author: 小莫
date: 2020-11-06
title: 聊聊Javascript的事件循环(转载)
tags:
- web
category: web
permalink: browserEventLoop

---

苹果的safari对不在一个事件循环内的popup操作判定为非用户主动触发，后果就是会被浏览器自动拦截。所以开始查询浏览器事件循环相关的资料，如果有遇到同样问题的小伙伴可以参考一下。

<!-- more -->

原地址 : [聊聊Javascript的事件循环](https://juejin.im/post/6844903653120163848)

## JavaScript、浏览器、事件之间的关系

JavaScript程序采用了异步事件驱动编程（Event-driven programming）模型，维基百科对它的解释是：

>   事件驱动程序设计（英语：Event-driven programming）是一种电脑程序设计模型。这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。相对于批处理程序设计（batch programming）而言，程序运行的流程是由程序员来决定。批量的程序设计在初级程序设计教学课程上是一种方式。然而，事件驱动程序设计这种设计模型是在交互程序（Interactive program）的情况下孕育而生的

简而言之，在web前端编程里面JavaScript通过浏览器提供的事件模型API和用户交互，接受用户的输入。

事件驱动程序模型基本的实现原理基本上都是使用 事件循环（Event Loop）。

而JS的运行环境主要有两个：浏览器、Node。

在两个环境下的Event Loop实现是不一样的，在浏览器中基于 [规范](https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops) 来实现，不同浏览器可能有小小区别。在Node中基于 libuv 这个库来实现

JS是单线程执行的，而基于事件循环模型，形成了基本没有阻塞（除了alert或同步XHR等操作）的状态。



### 浏览器中的事件循环 event loop

先看HTML标准的一系列解释：

>   为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 有两类事件循环：一种针对浏览上下文（browsing context），还有一种针对worker（web worker）。

为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲《[Help, I'm stuck in an event-loop](http://vimeo.com/96425312)》）

<img src="https://image.xiaomo.info//blog/image-20201106150325595.png" alt="image-20201106150325595" style="zoom: 50%;" />

上图中，主线程运行的时候，产生堆栈，栈中的代码调用各种外部API，异步操作执行完成后，就在消息队列中排队。只要栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。

##### 详细的步骤如下：

1.  所有同步任务都在主线程上执行，形成一个执行栈
2.  主线程之外，还存在一个“消息队列”。只要异步操作执行完成，就到消息队列中排队
3.  一旦执行栈中的所有同步任务执行完毕，系统就会依次读取消息队列的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
4.  主线程不断重复上面的的第三步

下面看一个有意思的例子，猜一下它的运行结果：

```js
setTimeout(
    function(){
        console.log('1')
},0);

new Promise(
    function(resolve){
        console.log('2');
        resolve()
}).then(
    function(){
        console.log('3');
});

console.log('4');
```

打印结果：

```json
2
4
3
1
```

这是为什么？是不是跟上面说的相违背了？其实这里面就有了两个概念宏任务（task／macrotask），微任务（microtask），下面我们来详细介绍一下这两个东东。

## Macrotask 与 Microtask

根据 [规范](https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops)，每个线程都有一个事件循环（Event Loop），在浏览器中除了主要的页面执行线程 外，Web worker是在一个新的线程中运行的，所以可以将其独立看待。

每个事件循环有至少一个任务队列（Task Queue，也可以称作Macrotask宏任务），各个任务队列中放置着不同来源（或者不同分类）的任务，可以让浏览器根据自己的实现来进行优先级排序

以及一个微任务队列（Microtask Queue），主要用于处理一些状态的改变，UI渲染工作之前的一些必要操作（可以防止多次无意义的UI渲染）

主线程的代码执行时，会将执行程序置入执行栈（Stack）中，执行完毕后出栈，另外有个堆空间（Heap），主要用于存储对象及一些非结构化的数据。

<img src="https://image.xiaomo.info//blog/image-20201106150407277.png" alt="image-20201106150407277" style="zoom:50%;" />

常见的macrotask有：

run <script>（同步的代码执行）
setTimeout
setInterval
setImmediate (Node环境中)
requestAnimationFrame
I/O
UI rendering



常见的microtask有：

process.nextTick (Node环境中)

Promise callback

Object.observe (基本上已经废弃)

MutationObserver



## 事件循环执行顺序

### 1. event loop 执行步骤：

1、执行宏任务（先进先出），一次循环只执行一个宏任务）
2、执行栈 —— 同步方法顺序执行，异步方法交给异步处理模块
3、执行栈为空时取出微任务执行（先进先出），直到微任务队列为空
4、更新UI渲染。完成一轮循环，反复执行1-4。（不一定每次循环都会渲染）



### 2.update the rendering 渲染更新：

在一轮event loop中多次修改同一dom，只有最后一次会进行绘制。
渲染更新（Update the rendering）会在event loop中的tasks和microtasks完成后进行，但并不是每轮event loop都会更新渲染，浏览器有自己的机制来确定是否要更新渲染。如果在一帧（16.7ms）里多次修改了dom，浏览器可能只会渲染绘制一次。
如果希望在每轮event loop都即时呈现变动，可以使用requestAnimationFrame.



那么我们回到上面的那个例子就不难解释了：

==注意==： Promise 自身的代码是同步执行的，只有 .then后的回调函数才是微任务。

主线程的执行过程：

1.  从宏任务队列（task）中取出 script，将所有同步代码推入执行栈中执行，遇到异步代码交给异步处理模块，异步处理模块处理完成后将任务按规则推入事件队列，宏任务推宏任务队列（先进先出），微任务推微任务队列（先进先出）。所以输出 2 和 4。
2.  执行完 script 中的同步代码，再将微任务队列中最老的任务推入执行栈执行，直到清空微任务队列。所以输出 3。
3.  浏览器更新渲染，再去宏任务队列中取出最老的任务推入执行栈中执行，循环以上步骤。所以输出 1。

## 在Node中的实现

在Node环境中，macrotask部分主要多了setImmediate，microtask部分主要多了process.nextTick，而这个nextTick是独立出来自成队列的，优先级高于其他microtask

不过事件循环的的实现就不太一样了，可以参考 [Node事件文档](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/) [libuv事件文档](http://docs.libuv.org/en/v1.x/design.html)

#### Node中的事件循环有6个阶段

1.  timers：执行setTimeout() 和 setInterval()中到期的callback
2.  I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行
3.  idle, prepare：仅内部使用
4.  poll：最为重要的阶段，执行I/Ocallback，在适当的条件下会阻塞在这个阶段
5.  check：执行setImmediate的callback
6.  close callbacks：执行close事件的callback，例如socket.on("close",func)

<img src="https://image.xiaomo.info//blog/image-20201106150543628.png" alt="image-20201106150543628" style="zoom: 25%;" />

每一轮事件循环都会经过六个阶段，在每个阶段后，都会执行microtask

<img src="https://image.xiaomo.info//blog/image-20201106150609147.png" alt="image-20201106150609147" style="zoom:25%;" />

比较特殊的是在poll阶段，执行程序同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限

接下来再检查有无预设的setImmediate，如果有就转入check阶段，没有就先查询最近的timer的距离，以其作为poll阶段的阻塞时间，如果timer队列是空的，它就一直阻塞下去

而nextTick并不在这些阶段中执行，它在每个阶段之后都会执行。

一个简单的例子：

```js
setTimeout(() => console.log(1));

setImmediate(() => console.log(2));

process.nextTick(() => console.log(3));

Promise.resolve().then(() => console.log(4));

console.log(5);
```

根据以上知识，应该很快就能知道输出结果是 5 3 4 1 2

修改一下：

```js
process.nextTick(() => console.log(1));

Promise.resolve().then(() => console.log(2));

process.nextTick(() => console.log(3));

Promise.resolve().then(() => {
    process.nextTick(() => console.log(0));
    console.log(4);
});
```

输出为 1 3 2 4 0，因为nextTick队列优先级高于同一轮事件循环中其他microtask队列



再次修改：

```js
process.nextTick(() => console.log(1));

console.log(0);

setTimeout(()=> {
    console.log('timer1');

    Promise.resolve().then(() => {
        console.log('promise1');
    });
}, 0);

process.nextTick(() => console.log(2));

setTimeout(()=> {
    console.log('timer2');

    process.nextTick(() => console.log(3));

    Promise.resolve().then(() => {
        console.log('promise2');
    });
}, 0);
```

输出结果为:

```json
0
1
2
timer1
timer2
3
promise1
promise2
```

与在浏览器中不同，这里promise1并不是在timer1之后输出，因为在setTimeout执行的时候是出于timer阶段，会先一并处理timer回调.

## 善用事件循环

知道JS的事件循环是怎么样的了，就需要知道怎么才能把它用好：

1.  在microtask中不要放置复杂的处理程序，防止阻塞UI的渲染
2.  可以使用process.nextTick处理一些比较紧急的事情
3.  可以在setTimeout回调中处理上轮事件循环中UI渲染的结果
4.  注意不要滥用setInterval和setTimeout，它们并不是可以保证能够按时处理的，setInterval甚至还会出现丢帧的情况，可考虑使用 requestAnimationFrame
5.  一些可能会影响到UI的异步操作，可放在promise回调中处理，防止多一轮事件循环导致重复执行UI的渲染
6.  在Node中使用immediate来可能会得到更多的保证

如有错误欢迎指正，相互进步。



参考链接：

[JavaScript 运行机制详解：再谈Event Loop](http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/)

[深入理解 JavaScript 事件循环（一）— event loop](https://www.cnblogs.com/dong-xu/p/7000163.html)

[深入浅出Javascript事件循环机制(上)](https://zhuanlan.zhihu.com/p/26229293)



# MDN中对并发模型与事件循环的讲解

JavaScript有一个基于**事件循环**的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。

## 运行时概念

接下来的内容解释了这个理论模型。现代JavaScript引擎实现并着重优化了以下描述的这些语义。

### 可视化描述



![Stack, heap, queue](https://mdn.mozillademos.org/files/17124/The_Javascript_Runtime_Environment_Example.svg)

### 栈



函数调用形成了一个由若干帧组成的栈。

```js
function foo(b) {
  let a = 10;
  return a + b + 11;
}

function bar(x) {
  let y = 3;
  return foo(x * y);
}

console.log(bar(7)); // 返回 42
```

当调用 `bar` 时，第一个帧被创建并压入栈中，帧中包含了 `bar` 的参数和局部变量。 当 `bar` 调用 `foo` 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 `foo` 的参数和局部变量。当 `foo` 执行完毕然后返回时，第二个帧就被弹出栈（剩下 `bar` 函数的调用帧 ）。当 `bar` 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。

### 堆



对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。

### 队列



一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。

在 [事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#事件循环) 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。

函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。

## 事件循环

之所以称之为 **事件循环**，是因为它经常按照类似如下的方式来被实现：

```js
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

`queue.waitForMessage()` 会同步地等待消息到达(如果当前没有任何消息等待被处理)。

### "执行至完成"



每一个消息完整地执行后，其它消息才会被执行。这为程序的分析提供了一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。这与C语言不同，例如，如果函数在线程中运行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。

这个模型的一个缺点在于当一个消息需要太长时间才能处理完毕时，Web应用程序就无法处理与用户的交互，例如点击或滚动。为了缓解这个问题，浏览器一般会弹出一个“这个脚本运行时间过长”的对话框。一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。

### 添加消息



在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。

函数 `setTimeout` 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，`setTimeout` 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。

下面的例子演示了这个概念（`setTimeout` 并不会在计时器到期之后直接执行）：

```js
const s = new Date().getSeconds();

setTimeout(function() {
  // 输出 "2"，表示回调函数并没有在 500 毫秒之后立即执行
  console.log("Ran after " + (new Date().getSeconds() - s) + " seconds");
}, 500);

while(true) {
  if(new Date().getSeconds() - s >= 2) {
    console.log("Good, looped for 2 seconds");
    break;
  }
}
```

### 零延迟



零延迟并不意味着回调会立即执行。以 0 为第二参数调用 `setTimeout` 并不表示在 0 毫秒后就立即调用回调函数。

其等待的时间取决于队列里待处理的消息数量。在下面的例子中，`"这是一条消息"` 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。

基本上，`setTimeout` 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。

```js
(function() {

  console.log('这是开始');

  setTimeout(function cb() {
    console.log('这是来自第一个回调的消息');
  });

  console.log('这是一条消息');

  setTimeout(function cb1() {
    console.log('这是来自第二个回调的消息');
  }, 0);

  console.log('这是结束');

})();

// "这是开始"
// "这是一条消息"
// "这是结束"
// "这是来自第一个回调的消息"
// "这是来自第二个回调的消息"
```

### 多个运行时互相通信



一个 web worker 或者一个跨域的 `iframe` 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 [`postMessage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage) 方法进行通信。如果另一个运行时侦听 `message` 事件，则此方法会向该运行时添加消息。

## 永不阻塞

JavaScript的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。 处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 [IndexedDB](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API) 查询返回或者一个 [XHR](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 请求返回时，它仍然可以处理其它事情，比如用户输入。

由于历史原因有一些例外，如 `alert` 或者同步 XHR，但应该尽量避免使用它们。注意，[例外的例外也是存在的](https://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311#2734311)（但通常是实现错误而非其它原因）。

## 标准规范

| 标准规范                                                     | 状态            | 注释 |
| :----------------------------------------------------------- | :-------------- | :--- |
| [HTML Living Standard Event loops](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) | Living Standard |      |
| [Node.js 事件循环](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop) | Living Standard |      |